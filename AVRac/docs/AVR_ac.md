# AVRac Library

This library can be usd with the Arduino IDE and also with other systems, such as PlatformIO. The library makes handling the Analog Comparator (AC) interrupt on the Arduino and/or a plain ATmega328P, very simple indeed.

## Library Documentation

### Analog Comparator - Brief Description

The AC is an internal feature of the ATmega328P. It has two inputs, the positive and the negative. Normally, these are Arduino pins `D6` and `D7` but the AC can be configured to use other pins. The data sheet refers to these pins as `AIN0` (positive) and `AIN1` (negative).

The *positive* input, `AIN0`, can be configured to read the reference voltage externally on the `AIN0` pin, or from the internal 1.1V bandgap reference voltage, generated by the ATmega328P.

The *negative* input, `AIN1`, can be configured to compare its voltage (with the reference voltage) on pin `AIN1` or on any of the ADC multiplexer's input pins. These are Arduino pins `A0` through `A5`---if the Arduino has a Through hole ATmega328P---or `A0` through `A7` if the surface mount version is in use.

The AC's output is a single bit, `ACO` (That's AC OH, and not AC Zero) in the Analog Comparator Control and Status Register, `ACSR`.


#### When Does the `ACO` Bit Change?

The `ACO` bit in `ACSR` will be set or cleared depending on the difference between the voltages on the positive and negative inputs.

If the reference voltage on the positive input is higher than the voltage on the negative input, the `ACO` bit will be set to 1.

If the reference voltage on the positive input is lower or equal to the voltage on the negative input, the `ACO` bit  in `ACSR` will be cleared to 0.


### Types

#### onInterrupt

This type defines the function that will be called when the interrupt is triggered. The function must be as follows:

```
void interruptFunction() {
    // Do something on interrupt here;
}
```

It will be called if, and only if, it has been attached to the interrupt by the `onInterruptTriggered()` function. See below for details.

### refVoltage_t

* **ac::VREF_INTERNAL**  The internal 1.1V bandgap reference voltage will be used as the reference voltage.
* **ac::VREF_EXTERNAL**  The reference voltage will be applied to pin `AIN0`/`PD6`/`D6`. This can be any voltage between 0 and 5V. 


#### trigger_t

The `trigger_t` type defines the 3 different triggers that can be passed to the `begin()` function. The different values are:

* **ac::TRGR_CHANGE**       The AC interrupt fires whenever the `ACO` bit in the `ACSR` register changes -- from 0 to 1 or from 1 to 0.
* **ac::TRGR_FALLING**      The AC interrupt triggers whenever the `ACO` bit in the `ACSR` register changes from 1 to 0.
* **ac::TRGR_RISING**       The AC interrupt triggers whenever the `ACO` bit in the `ACSR` register changes from 0 to 1.

Global interrupts must be enabled for the ISR to execute. This is the default on an Arduino, but other systems will require the explicit enabling of interrupts.

#### testVoltage_t

The `testVoltage_t` defines which pin will be used as the negatiove input to the AC. The different values are:

* **ac::VTEST_A0_PC0**   The Arduino `A0` pin, AVR pin `PC0` will be used as the negative input.
* **ac::VTEST_A1_PC1**   The Arduino `A1` pin, AVR pin `PC1` will be used as the negative input.
* **ac::VTEST_A2_PC2**   The Arduino `A2` pin, AVR pin `PC2` will be used as the negative input.
* **ac::VTEST_A3_PC3**   The Arduino `A3` pin, AVR pin `PC3` will be used as the negative input.
* **ac::VTEST_A4_PC4**   The Arduino `A4` pin, AVR pin `PC4` will be used as the negative input.
* **ac::VTEST_A5_PC5**   The Arduino `A5` pin, AVR pin `PC5` will be used as the negative input.
* **ac::VTEST_A6**       The Arduino `A6` pin, AVR pin `PC6` will be used as the negative input. (Surface mount ATmega329PAU only.)
* **ac::VTEST_A7**       The Arduino `A7` pin, AVR pin `PC7` will be used as the negative input. (Surface mount ATmega329PAU only.)
* **ac::VTEST_D7_AIN1**  The Arduino `D7` pin, AVR pin `PD7`/`AIN1` will be used as the negative input.

#### inputCapture_t

The AC has the ability to direct its `ACO` bit to Timer/Counter 1's  *Input Capture Unit* (ICU). This lets the application use the AC interrupt for one purpose, and the ICU's interrupt for another. The different values for this type are:

* **ac::INPCAP_OFF**     The `ACO` bit is not connected to the ICU.
* **ac::INPCAP_ON**      The `ACO` bit is connected to the ICU.
  

### Functions


**`void AVRac.begin(...)`**

The full template for the `begin()` function is:

```
    void begin(trigger_t trigger,
               refVoltage_t vReference = ac::VREF_EXTERNAL,
               testVoltage_t vTest = ac::VTEST_D7_AIN1,
               inputCapture_t inpCapture = ac::INPUTCAPT_OFF);
```

The parameters allow the AC to be configured with the various positive and negative inputs, when to trigger the interrupt and whether it is directly connected to the Timer/counter 1 Input Capture Unit. The defaults are:

* The positive input is pin `AIN0`, Arduino pin `D6` also known as `PD6`. This is where the reference voltage will be found.
* The negative input is pin `AIN1`, Arduino pin `D7` also known as `PD7`. This is where the voltage being comparaed with the reference voltage will be found.
* The Input capture Unit is disconnected from the AC.

The only mandatory parameter is the trigger which determines when the interrupt will fire.

Calling `begin()` will configure the AC and immediately start it running -- there is no need to call `enable()` after calling `begin()`.

**NOTE** You must call `begin()` after setting the function to be called when the interrupt fires.

For example:

```
// Do this first!
AVRac.onInterruptTriggered(someFunctionName);

// Do this next, to config and start the AC.
AVRac.begin(ac::TRGR_CHANGE,
            ac::VREF_EXTERNAL,
            ac::VTEST_D7_AIN1,
            ac::INPUTCAPT_OFF);
```


**`void AVRac.disable()`**

Disables the AC and any interrupt handling. This may be permanently, or temporarily. To re-enable the interrupt handling, simply call `enable()` again.

For example:

```
AVRac.disable();
```

All that  this function does is to power off the AC. It does not reconfigure the AC in any way -- all your previous settings remain. No interrupts will trigger when disabled, but the interrupt flag internal to the ATmega328P, will be set if the AC inputs determine.


**`void AVRac.enable(trigger_t trigger)`**

Enables the AC and clears any pending interrupts. The interrupt may be triggered from this point onwards. The AC is enabled with all previous configuration intact.

For example, to enable the interrupt after calling `disable()`, use:

```
// Restart the AC with no config changes.
AVRac.enable();
```

**`void AVRac.onInterruptTriggered(onInterrupt functionName)`**

This function attaches a function in your code to the INT0 interrupt. The function will be called each time the interrupt is triggered.

```
void myFunction() {
    digitalWrite(13, HIGH);
}

void setup() {
...
   AVRac.onInterruptTriggered(myFunction);
...
}
```

**`void AVRac.interrupt()`**

This function is intended for internal use only. It is what allows the ISR (Interrupt Service Routine) for the AC to execute the function passed to `onInterruptTriggered()`.

The `interrupt()` function can be called from user code, as a means of manually executing the interrupt function, but this feature should be used with great care.

The function has to be `public` because the ISR isn't part of the `AVRac` object, and cannot be. (Unless you know different?)


## Steps in Setting Up the Interrupt

Once the library has been installed on your system, it is simple to use. All you are required to do is:

* `#include AVR_ac.h`;
* Write a `void` function which takes no parameters to handle the interrupt;
* Call `AVRac.onInterruptTriggered()` passing your function's name;
* Call `AVRac.begin()` with suitable parameters;
* That's it!

Taking each step in order, we have....

### The Header file

Adding the header file is simple. In your main source file, just add the following line at the top somewhere:

```
#include AVR_ac.h
```

That's all. When you do this, a new object is created in the background. This is named `AVRac` (note the lack of an underscore in the name!) and this object controls the interrupts. At the moment, however, it is disabled and not yet configured.


### The Interrupt Function

You need to write a function to handle the interrupt, when one occurs. The function should look like this:

```
void myInterruptFunction() {
    // Do something ...
}
```

The function takes no parameters and does not return a result.

To add this function to the interrupt requires the following line:

```
// This must be carried out before calling begin().
AVRac.onInterruptTriggered(myInterruptFunction);
```

Note, there are no parenthesis on the end of `myInterruptFunction` in the above. That would not work!

All that is required now is to configure the AC and start it running.


### Enabling the Interrupt

```
// Configure and start the AC.
AVRac.begin(ac::TRGR_CHANGE,
            ac::VREF_EXTERNAL,
            ac::VTEST_D7_AIN1,
            ac::INPUTAPT_OFF);
```

With the current defaults for the `begin()` function, the above is equivalent to:

```
// Configure and start the AC.
AVRac.begin(ac::TRGR_CHANGE);
```



## Example Sketches


### Example Arduino Sketch

The following code shows an example of using this interrupt to toggle an LED. The builtin LED will flash with a 5 second intervale to pretend to be doing some work. The LED attached to `D8` will be lit or extinguished according to the `ACO` bit which itself is set or reset by the Analog Comparator.


```
//============================================================
// AVRac Demonstration.
//============================================================
// Attach a reference voltage to AIN0/D6. Connect this pin
// to the Arduino's 3.3V power output.
//
// Attach a potentiometer (value can be almost anything) to
// VCC and GND, the wiper connects to AIN1/D7.
//
// Attach an LED to D13 and toggle it in the loop.
//
// Another LED on D8 will be toggled according to whether 
// the potentiometer voltage is higher or lower than 3.3V.
//
// Norman Dunbar
// 27th October 2020.
//============================================================

#include "AVR_ac.h"


// The function to call when the AC interrupt triggers.
void toggleLED() {
    // Read the ACO bit and if on, light the LED on PB0
    // otherwise, extinguish it.
    digitalWrite(8,!!(ACSR & (1 << ACO)));
}


void setup() {
    // D8 and D13 are outputs. Turn both LEDs off.
    pinMode(8, OUTPUT);
    pinMode(LED_BUILTIN, OUTPUT);
    digitalWrite(8, LOW);
    digitalWrite(LED_BUILTIN, LOW);
    
    // Configure the Analog Comparator. Do this before
    // calling begin().
    AVRac.onInterruptTriggered(toggleLED);
    
    AVRac.begin(ac::TRGR_CHANGE,
                ac::VREF_EXTERNAL,
                ac::VTEST_D7_AIN1,
                ac::INPUTCAPT_OFF);

}

void loop() {
    // Toggle built in LED every 5 seconds.
    digitalWrite(LED_BUILTIN, HIGH);
    delay(5000);
    digitalWrite(LED_BUILTIN, LOW);
    delay(5000);
}

```

### Example PlatformIO Sketch

The following code shows a similar sketch to the Arduino one above. In this case, the LED attached to `D8` will be lit or extinguished depending on the voltages on Arduino pin `D6` aka `PD6`/`AIN0` and the ADC MUX pin, `PC3` which on the Arduino is `A3`.

```
//============================================================
// AVRac MUX Demonstration.
//============================================================
// Attach a reference voltage to AIN0/PD6/D6. Connect this pin
// to the Arduino's 3.3V power output.
//
// Attach a potentiometer (value can be almost anything) to
// VCC and GND, the wiper connects to A3/D17/PC3.
//
// Attach an LED to PB5/D13 and toggle it in the loop.
//
// Another LED on PB0/D8 will be toggled according to whether
// the potentiometer voltage is higher or lower than 3.3V.
//
// Norman Dunbar
// 27th October 2020.
//============================================================

#include "AVR_ac.h"
#include <util/delay.h>


// The function to call when the AC interrupt triggers.
void toggleLED() {
    // Read the ACO bit and if on, light the LED on PB0
    // otherwise, extinguish it.
    if (ACSR & (1 << ACO)) {
        PORTB |= (1 << PORTB0);
    } else {
        PORTB &= ~(1 << PORTB0);
    }
}


int main() {

    // SETUP:
    // PB0/D8 and PB5/D13 are outputs. Turn
    // both LEDs off.
    DDRB |= ((1 << DDB5) | (1 << DDB0));
    PORTB &= ~((1 << PORTB5) | (1 << PORTB0));

    // Configure the Analog Comparator. Do this before
    // calling begin().
    AVRac.onInterruptTriggered(toggleLED);

    AVRac.begin(ac::TRGR_CHANGE,
                ac::VREF_EXTERNAL,
                ac::VTEST_A3_PC3,
                ac::INPUTCAPT_OFF);

    // Enable Global interrupts. (Best we don't forget!)
    sei();


    // LOOP:
    while (1) {
        // Toggle built in LED on PB5/D13 every 5 seconds.
        PINB |= (1 << PINB5);
        _delay_ms(5000);
    }
}
```

